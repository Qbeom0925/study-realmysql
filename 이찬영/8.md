# 8 인덱스

인덱스는 데이터베이스의 쿼리 성능에 매우 중요한 부분.  
8장에서는 MySQL에서 사용 가능한 인덱스의 종류 및 특성을 간단히 살펴보자.  
각 인덱스의 특성과 차이는 매우 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 된다.  
MySQL 8.0버전까지 오면서 기존의 MyISAM 스토리지 엔진에만 있던 전문 검색이나 위치 기반 검색 기능도 모두 InnoDB 스토리지 엔진에서 사용할 수 있게 되었다. 하지만 아무리 MySQL 서버의 옵티마이저가 발전하고 성능이 개선됐다고 해도 여전히 관리자의 역할이 매우 중요하다. 해서 인덱스에 대한 기본 지식은 매우 중요하며, 쿼리 튜닝의 기본이 될 것이다.

## 8.1 디스크 읽기 방식

먼저 랜덤 I/O(Random), 순차 I/O(Sequential)와 같은 디스크 읽기 방식을 먼저 간단히 살펴보자.  
CPU나 메모리같은 전기적 특성을 띤 장치는 매우 빠르게 발전했지만 디스크같은 기계식 장치의 성능은 상당히 제한적으로 발전했다. 데이터 저장 매체(SSD/HDD)는 컴퓨터에서 가장 느린 부분이다. 하여 데이터베이스의 성능 튜닝은 어떻게 디스크I/O를 줄이냐가 관건이다.

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 컴퓨터에서 CPU나 메모리는 전자식 장치지만 하드 디스크 드라이브는 기계식 장치이다.
- 하여 데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다.
- 기계식 하드 디스크 드라이브를 대체하기 위해 전자식 저장 매체인 SSD가 많이 출시되고 있다.
  > SSD(Solid State Drive)
  >
  > - SSD도 기존 하드 디스크 드라이브와 같은 인터페이스를 지원하므로 DAS, SAN에 그대로 사용할 수 있다.
  > - SSD는 기존 HDD에서 데이터 저장용 플레터(원판)을 제거하고 그 대신 플래시 메모리를 장착하고 있다. 해서 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.
  > - 플레시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않으며, 컴퓨터 메모리(d-ram)보다는 느리지만 HDD보단 훨 빠르다.
  > - 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차I/O에서는 SSD가 HDD보다 조금 빠르거나 거의 비슷하다. (HDD의 성능 저하 요인이 헤더를 움직여야 하는 것이므로 헤더를 움직이지 않는다면 SSD와 속도가 비슷함)
  > - SSD의 장점은 HDD보다 랜덤 I/O가 훨씬 빠르다는 것이다.
  > - 데이터베이스 서버에서 순차 I/O 작업은 그다지 많지 않고 랜덤 I/O를 하는 것이 대부분이므로 SSD는 데이터베이스의 작업에 최적이라고 할 수 있다.

### 8.1.2 랜덤 I/O와 순차 I/O

랜덤 I/O라는 표현은 HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 사실 순차 I/O도 이 작업 과정은 같다. 그렇다면 순차 I/O와 대체 어떤 차이가 있는지 알아보자.  
 <img src="./img/812.png" width="70%" height="70%" title="200px" alt=""></img>  
 (왼)순차I/O (오)랜덤I/O

순차 I/O는 3개의 페이지(3x16KB)를 디스크에 기록하기 위해 1번 시스템 콜을 요청하지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템콜을 요청한다.

- 즉 디스크에 기록해야할 위치를 찾기 위해 순차 I/O는 디스크의 헤더를 1번 움직였고, 랜덤 I/O는 3번 움직였다.
- 디스크에 데이터를 읽고 쓰는데 걸리는 시간 == 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 시간
- 즉 위 그림에서 순차 I/O가 랜덤 I/O보다 거의 3배 빠름
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정
- 여러 번 읽고 쓰기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 크다.
- 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.
- 디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O의 차이가 없을 것으로 예측하지만, 실제로 그렇지 않음
- SSD 드라이브에서도 랜덤 I/O는 여전히 순차 I/O보다 전체 처리량(Throughput)이 떨어진다. 해서 SSD에서도 항상 랜덤 I/O와 순차 I/O의 성능 비교를 구분해서 명시한다.
- 사실 쿼리를 튜닝하여 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 많지 않음.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O를 줄이는 것이 목적이다. 여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

  > 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하며, 풀 데이터 스캔은 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다. 이런 형태는 OLTP(On-Line Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.

## 8.2 인덱스란?

인덱스 - 책의 맨 마지막의 색인  
데이터 파일 - 책의 내용  
데이터 파일에 저장된 레코드의 주소 - 책의 찾아보기를 통해 알아낼 수 있는 페이지  
DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)으로 삼아 인덱스를 만들어 두는 것이다.  
또한 책의 "찾아보기"와 DBMS 인덱스의 공통점 가운데 중요한 것이 바로 정렬이다. 책의 찾아보기도 내용이 많아지면 우리가 원하는 검색어를 찾아내는데 시간이 걸릴것이다. 해서 최대한 빠르게 찾아갈 수 있도록 가나다 순으로 정렬되어 있는데, 인덱스도 칼럼의 값을 주어진 순서대로 미리 정렬해서 보관한다.

프로그래밍 언어의 자료 구조로 인덱스와 데이터 파일을 비교해가며 살펴보자. 자료구조에 SortedList와 ArrayList라는 자료구조가 있는데 DBMS 인덱스는 Sortedlist, 데이터 파일은 Arraylist와 같은 자료 구조이다.

- Sortedlist : 저장되는 값을 항상 정렬된 상태로 유지.
- Arraylist : 값을 저장되는 순서 그대로 저장.

그렇다면 이제 sortedlist의 장단점을 통해 인덱스의 장단점을 살펴보자.

- 자료구조가 항상 저장될 때 마다 값을 정렬해야하므로 저장하는 과정이 복잡하고 느리다.
- 하지만 이미 정렬되어 있기 때문에 원하는 값을 빠르게 찾을 수 있다.
- 즉 INSERT, UPDATE, DELETE 문장의 처리가 느리지만
- SELECT는 매우 빠르다.

결론적으로 DBMS의 인덱스는 INSERT, UPDATE, DELETE 성능을 희생시키고 SELECT(읽기) 속도를 높이는 기능이다.  
테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있고, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정된다.  
SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.

인덱스는 데이터를 관리하는 방식(알고리즘)과 중복 값의 허용 여부에 따라 여러 가지로 나눠볼 수 있다. (해당 분류는 책에서 저자가 임의로 분류한 것. 추가적으로 해당 책에서는 Key라는 말과 인덱스를 같은 의미로 사용한다.)  
인덱스를 역할별로 구분하면 프라이머리 키(Primary key)와 보조 키(세컨더리 인덱스, Secondary key)로 구분할 수 있다.

- 프라이머리 키 : 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. 이 칼럼은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 된다. 해서 이를 식별자라고도 부른다. 프라이머리키는 NULL값을 허용하지 않으며 중복을 허용하지 않는 것이 특징.
- 세컨더리 인덱스 : 프라이머리 키를 제외한 나머지 모든 인덱스. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데, 별도로 분류하기도, 세컨더리 인덱스로 분류하기도 한다.

데이터 저장 방식(알고리즘)별로 구분할 경우 더 많은 분류가 가능하지만 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있음. (최근에는 Fractal-Tree 인덱스나 Merge-Tree 알고리즘을 사용하는 DBMS도 개발되고 있음)

- B-Tree : 가장 일반적으로 사용되는 인덱스 알고리즘. B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘. MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.
- Hash : 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원함. 하지만 값을 변형해서 인덱싱하므로 전방(Prefix)일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다. Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

데이터 중복 허용 여부로 분류하면 유니크 인덱스(Unique)와 유니크하지 않은 인덱스(Non-Unique)로 구분할 수 있다. 인덱스가 유니크한지 유니크하지 않은지는 단순히 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제다.  
유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다. 뿐만 아니라 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점이 많다. 이러한 부분은 인덱스와 쿼리의 실행계획을 살펴보면서 배울 것이다.  
인덱스의 기능별로 분류해보면 전문 검색용 인덱스나 공간 검색용 인덱스등을 예로 들 수 있다. 이들은 더 뒤에서 살펴본다.

### 8.3 B-Tree 인덱스

- B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘.
- B-Tree에는 여러가지 변형된 형태의 알고리즘이 있는데, 주로 B+-Tree 또는 B\*-Tree가 사용된다.
- 추가적으로 B-Tree의 B는 'binary'가 아닌 'balanced'이다.
- B-Tree는 칼럼의 원래의 값을 변형하지 않고(일부분만 잘라서 관리하긴 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
- 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.

#### 8.3.1 B-Tree의 구조 및 특성

- B-Tree는 트리 구조의 최상위에 하나의 루트 노드(Root node)가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다.
- 트리의 가장 하위 노드는 리프 노드(leaf node), 루트도 리프도 아닌 노드를 브랜치 노드라고 한다.
- 데이터베이스에서 인덱스와 실제 데이터는 항상 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- 아래 그림은 B-Tree 인덱스의 각 노드와 데이터 파일의 관계를 표현한 것이다.

<img src="./img/831.png" width="70%" height="70%" title="200px" alt=""></img>

- 위 그림에서 보이는 것처럼 인덱스 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 임의의 순서로 저장돼 있다.
- 추가로 데이터 파일은 반드시 INSERT된 순으로 데이터를 저장하지 않는다. INSERT만 수행하면 모르겠지만 DBMS는 어떤 레코드가 삭제되면 최대한 삭제된 레코드의 빈 공간에 INSERT를 하여 공간을 재활용한다.

  > 참고  
  > 대부분 DBMS의 데이터파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다. 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다. 다른 DBMS에서는 클러스터링 기능이 선택사항이지만, InnoDB애서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다. 클러스터링이란 비슷한 값을 최대한 모아서 저장하는 방식을 말한다. 더 뒤에서 자세히 다룬다.

- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다. 그림 8.5와 8.6은 인덱스의 리프 노드와 데이터 파일의 이러한 관계를 보여준다.

<img src="./img/8311.png" width="70%" height="70%" title="200px" alt=""></img> 그림8.5
<img src="./img/8312.png" width="80%" height="70%" title="200px" alt=""></img>그림8.6

- 그림 8.5는 MyISAM 테이블의 인덱스와 데이터 파일의 관계를 보여주는데, "레코드 주소"는 MyISAM 테이블의 생성 옵션에 따라 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)다.
- MyISAM 스토리지 엔진에서 인덱스의 구조는 4.3.3절 '데이터 파일과 프라이머리 키(인덱스) 구조'의 ROWID 설명을 참고하자.

- 그림 8.6은 InnoDB 테이블의 인덱스의 데이터 파일의 관계를 보여준다.
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리 키가 ROWID 역할을 한다.
  > "ROWID"는 데이터베이스 테이블의 각 레코드(행)를 식별하는 고유한 식별자. 이는 각 행이 데이터베이스 내에서 물리적으로 저장될 때 사용되는 고유한 주소 또는 위치를 가리킨다.
- 두 스토리지 엔진의 인덱스에서 가장 큰 차이점은 세컨더리 인덱스를 통해 데이터 파일에 데이터 파일의 레코드를 찾아가는 방법에 있음.
  - MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면
  - InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 할 수 있음.
- 위와 같은 이유로 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 그림 8.5처럼 데이터 파일을 바로 찾아가지 못한다.
- 그림 8.6처럼 인덱스에 저장되어 있는 프러이머이 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
- 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.
- 이것만 보면 InnoDB를 사용한 테이블이 성능이 떨어질 것 같지만, MyISAM과 InnoDB는 각각 장단점이 있다. 이는 8.8에서 살펴본다.
