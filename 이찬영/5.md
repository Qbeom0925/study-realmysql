5장에서는 MySQL의 동시성에 영향을 미치는 잠금(Lock)과 트랜잭션, 트랜잭션 격리 수준(Isolation Level)을 살펴보겠다.

트랜잭션은 작업의 완전성을 보장해 줌.  
즉 논리적인 작업 셋을 모두 완변하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Patial update)를 막는다.  
잠금 : 동시성을 제어하기 위한 기능  
트랜잭션 : 데이터의 정합성을 보장하기 위한 기능  
격리 수준 : 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨
트랜잭션과 잠금은 비슷한 것 같지만 다르다.

ex)  
하나의 회원정보 레코드를 여러 커넥션에서 동시에 변경 시도

잠금이 없는 경우 :

- 여러 커넥션에서 동시에 변경 가능.
- 결과적으로 해당 레코드의 값은 예측할 수 없게 됨.

잠금이 있는 경우 :

- 잠금이 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나으 커넥션만 변경하게 해줌

# 5.1 트랜잭션

트랜잭션을 지원하지 않는 MyISAM과 트랜잭션을 지원하는 InnoDB의 처리 방식의 차이를 살펴보고, 트랜잭션을 사용할 경우 주의할 사항도 함께 살펴보자.

## 5.1.1 MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT) 아무것도 적용되지 말아야 함(ROLLBACK)을 보장해주는 것이다.

트랜잭션 관점에서 InnoDB와 MyISAM의 차이를 예제로 살펴보자.
테이블MYISAM, 테이블INNODB라는 테이블은 id라는 INT타입의 레코드를 각각 갖는다고 해보자.
그래서 아래와 같은 쿼리를 수행한다.

> mysql > insert into 테이블MYISAM (id) values (3);
> mysql > insert into 테이블INNODB (id) values (3);

위의 결과는 당연하게도 id 값이 3인 레코드들이 잘 들어갈 것이다.

그런데 아래와 같은 sql을 실행한다고 해보자.

> mysql > insert into 테이블MYISAM (id) values (1), (2), (3);  
> ERROR 1062 (23000): Duplicate entry "3' for key 'PRIMARY'
>
> mysql > insert into 테이블INNODB (id) values (1), (2), (3);
> ERROR 1062 (23000): Duplicate entry "3' for key 'PRIMARY'

위 쿼리의 결과는 당연히 pk값인 3이 이전에 insert한 데이터와 중복되었기 때문에 에러가 발생할 것이다.

하지만 테이블을 조회해보면 아래와 같다.

> mysql > select \* from 테이블MYISAM;  
> +----+  
> | id |  
> +----+  
> | 1 |  
> +----+  
> | 2 |  
> +----+  
> | 3 |  
> +----+

> mysql > select \* from 테이블INNODB;  
> +----+  
> | id |  
> +----+  
> | 1 |  
> +----+

결과를 보면 MYISAM 테이블은 오류가 발생했음에도 1과 2가 insert되었다.  
이는 insert문이 실행되면서 1과 2는 차례대로 저장하고, 3을 저장하려는 순간 에러가 발생하게 된 것이다.  
하지만 MyISAM은 트랜잭션의 개념이 없기 때문에 1과 2는 그대로 저장된다.

하지만 InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만드는 트랜잭션의 원칙대로 insert문을 실행하기 전 상태로 복구했다.

MyISAM의 이러한 현상을 부분 업데이트(Partial update)라고 하며 이는 테이블 데이터의 정합성을 맞추는 것을 어렵게 한다.  
부분 업데이트 현상이 발생하면 실패한 쿼리로 인해 남은 레코드를 다시 삭제해야 하는 대처리 작업이 필요할 수 있다. 실행한 쿼리가 하나뿐이라면 재처리 작업이 간단하겠지만 2개 이상의 쿼리가 실행되는 경우라면 실패에 대한 재처리 작업이 복잡해질 것이다.

## 5.1.2 주의사항

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. <== 프로그램의 코드에서 트랜잭션의 범위를 최소화하라는 의미

아래 예시는 사용자가 게시판에 게시물을 작성한 후 저장 버튼을 클릭했을 때 서버에서 처리하는 내용을 순서대로 간략하게 정리한 것이다.

> 1. 처리 시작  
>    ==> 데이터베이스 커넥션 생성  
>    ==> 트랜잭션 시작
> 2. 사용자의 로그인 여부 확인
> 3. 사용자의 글쓰기 내용 오류 여부 확인
> 4. 첨부로 업로드된 파일 확인 및 저장
> 5. 사용자의 입력 내용을 DBMS에 저장
> 6. 첨부 파일 정보를 DBMS에 저장
> 7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8. 게시물 등록에 대한 알림 매일 발송
> 9. 알림 메일 발송 이력을 DBMS에 저장  
>    <== 트랜잭션 종료(COMMIT)  
>    <== 데이터베이스 커넥션 반납
> 10. 처리 완료

위 처리 절차에서 DBMS의 트랜잭션 처리에 좋지 않은 영향을 미치는 부분을 살펴보자.

- 현재 트랜잭션은 1,2번 사이에서 시작하고 9,10번 사이에서 트랜잭션을 종료하고 있다. 그런데 실제로 트랜잭션을 사용하여 5번부터이다. 2,3,4번의 로직이 아무리 빨리 실행된다고 하여도 굳이 DBMS를 사용하지 않는 부분을 트랜잭션에 포함시킬 필요는 없다.  
  일반적으로 데이터 베이스 커넥션은 개수가 제한적이라 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여우 커넥션의 수는 줄어들 것이다.

- 더 위험한 것은 8번 작업이다. 외부와 네트워크 통신을 하는 작업은 무조건 DBMS의 트랜잭션 내에서 제거하는 것이 좋다. 프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생하면 웹 서버뿐만 아니라 DBMS 서버까지 위험해질 수 있다.

- 또한 이 처리 절차에는 DBMS의 작업이 크게 4개가 있다. 사용자가 입력한 정보를 저장하는 5,6번은 반드시 하나의 트랜잭션으로 묶어야 하고, 7번은 단순 조회이므로 트랜잭션으로 묶지 않아도 된다(또한 7번은 단순 조회이기 때문에 굳이 다른 트랜잭션을 사용하지 않아도 될 것같다.) 9번은 작업의 성격이 다르기에 5,6번과 함께 묶지 않아도 된다.

문제가 되는 3가지 부분을 수정한 것을 보자.

> 1. 처리 시작
> 2. 사용자의 로그인 여부 확인
> 3. 사용자의 글쓰기 내용 오류 여부 확인
> 4. 첨부로 업로드된 파일 확인 및 저장  
>    ==> 데이터베이스 커넥션 생성  
>    ==> 트랜잭션 시작
> 5. 사용자의 입력 내용을 DBMS에 저장
> 6. 첨부 파일 정보를 DBMS에 저장  
>    <== 트랜잭션 종료(COMMIT)
> 7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8. 게시물 등록에 대한 알림 매일 발송  
>    ==> 트랜잭션 시작
> 9. 알림 메일 발송 이력을 DBMS에 저장  
>    <== 트랜잭션 종료(COMMIT)  
>    <== 데이터베이스 커넥션 반납
> 10. 처리 완료

- 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다.
- 프로그램의 코드에서 라인 수는 한두 줄이라고 하더라도 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.
- 위와 같은 실수로 인해 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 발생할 수 있다.
